from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_sqlalchemy import SQLAlchemy
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from datetime import datetime, timezone
import os
from dotenv import load_dotenv

load_dotenv()

app = Flask(__name__)

# Configuration from environment variables
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'dev-secret-key')
app.config['ENV'] = os.getenv('FLASK_ENV', 'development')

#DB configuration
basedir = os.path.abspath(os.path.dirname(__file__))
db_name = os.getenv('DATABASE_NAME', 'notes.db')
app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{os.path.join(basedir, db_name)}'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

app.config['RATELIMIT_STORAGE_URI'] = os.getenv('RATELIMIT_STORAGE_URI', 'memory://')

#Initialise DB
db = SQLAlchemy(app)

# Initialize Rate Limiter
limiter = Limiter(
    get_remote_address,
    app=app,
    default_limits=[
        f"{os.getenv('RATE_LIMIT_PER_MINUTE', '60')} per minute",
        f"{os.getenv('RATE_LIMIT_PER_HOUR', '1000')} per hour"
    ],
    storage_uri=app.config['RATELIMIT_STORAGE_URI']
)

#Define Note Model
class Note(db.Model):
    __tablename__ = 'notes'

    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc))

    def to_dict(self): 
        """Convert Note object to dictionary for JSON response."""
        return {
            'id': self.id,
            'content': self.content,
            'timestamp': self.timestamp.isoformat()
        }
    
    def __repr__(self):
        """String representation for debugging."""
        return f'<Note {self.id}: {self.content[:20]}...>'
    


# CORS Configuration from environment variables
allowed_origins = os.getenv('ALLOWED_ORIGINS', 'http://localhost:5173').split(',')

CORS(app, resources={
    r"/api/*": {
        "origins": allowed_origins,
        "methods": ["GET", "POST", "PUT", "DELETE"],
        "allow_headers": ["Content-Type", "Authorization"]
    }
})


@app.route("/api")
def welcome():
    return "<h1>Welcome to the Note Taker App!</h1>"

@app.route("/api/notes", methods=["POST"])
@limiter.limit("10 per minute")
def create_note():
    data = request.json
    note_content = data.get("content", "")

    if not note_content:
        return {"error": "Note content cannot be empty"}, 400
    # Create new Note instance, id and timestamp are auto-generated by DB
    note = Note(content=note_content)
    # Add to DB session and commit
    db.session.add(note)
    db.session.commit()

    return jsonify({"message": "Note created", "note": note.to_dict()}), 201


@app.route("/api/notes", methods=["GET"])
def get_notes():
    page = request.args.get("page", 1, type=int)  # Get page from query params, default to 1
    notes_per_page = 5
    
    # Query notes with pagination (newest first)
    pagination = Note.query.order_by(Note.timestamp.desc()).paginate(
        page=page,
        per_page=notes_per_page,
        error_out=False
    )

    # Converts notes to dictionaries
    notes_list = [note.to_dict() for note in pagination.items]
    
    return {
        "notes": notes_list,
        "currentPage": pagination.page,
        "totalPages": pagination.pages,
        "totalNotes": pagination.total
    }, 200


@app.route("/api/notes/<int:note_id>", methods=["GET"])
def get_note(note_id):
    """Get a single note by its ID."""
    note = Note.query.get(note_id)

    #If note not found return 404
    if note is None:
        return {"error": "Note not found"}, 404
    
    # If found, return the note
    return note.to_dict(), 200


@app.route("/api/notes/<int:note_id>", methods=["PUT"])
@limiter.limit("20 per minute")
def update_note(note_id):
    data = request.json
    new_content = data.get("content", "")

    if not new_content:
        return {"error": "Note content cannot be empty"}, 400

    # Find note by ID
    note = Note.query.get(note_id)

    if note is None:
        return {"error": "Note not found"}, 404
    
    # Update note content and timestamp
    note.content = new_content
    note.timestamp = datetime.now(timezone.utc)

    # Commit changes to DB
    db.session.commit()

    return {"message": "Note updated", "note": note.to_dict()}, 200


@app.route("/api/notes/<int:note_id>", methods=["DELETE"])
@limiter.limit("10 per minute")
def delete_note(note_id):
    note = Note.query.get(note_id)

    if note is None:
        return {"error": "Note not found"}, 404

    # Delete note from DB
    db.session.delete(note)
    db.session.commit()

    return {"message": f"Note with id {note_id} deleted"}, 200


#Create DB tables
with app.app_context():
    db.create_all()
    print("Database tables created successfully.")

if __name__ == "__main__":
    app.run(debug=True)